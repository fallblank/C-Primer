# 《C++Preimer》学习

## 第二章：变量与基本类型
1.关于类型的选择建议
- 当明确数值不可能为负时，选用无符号类型。
- 使用int执行整数运算。</br>
short表示范围太小，long一般和int表示范围一样。如果超过int表示范围，选择long long
- 算数表达式尽量不要出现bool或char类型。</br>
char的实现在不同机器上可能不一样，可能为unsigned char 或者 signed char。bool就更不知道了，首先C++标准没有定义它的大小，其次根据C++非0为真的情况，很可能你存储的任何非0值都是1。
- 浮点运算用double。</br>
float不一定能带来更好的性能，long double的开销不可忽略（未切实体验过）</br>

2.关于强制类型转换
- bool转换为非bool时，true为1，false为0。
- 为无符号类型赋予超出范围的值，其结果为值对表示范围取模的结果。</br>
如unsigned char i = -1;结果为-1%256=255，所用i实际为255.
- 为带符号类型赋予超出范围的值时，结果不可预测。

3.关于类型转换的一些坑
- 算数表达式中同时出现了无符号数同时又出现了int等有符号数时，int会被转换为无符号数。
- 不要混用无符号类型和带符号类型。

4.关于字面值
- 十进制字面值是带符号的，八进制，十六进制可能带也可能不带。这取决与实际容纳它的类型。
- 十进制字面值的类型是int、long、long long中尺寸最小的那个。
- 八进制、十六进制字面值的类型是int、unsigned int、long、unsigned long、long long、unsigned long long中可容纳字面值最小的那个。
- 浮点型字面值是double，支持科学计数法。
- 字符串字面值是由常量字符构成的数组。
- 当两个字符串字面值位置相邻且仅由空格、缩进、换行符分隔时，它们实际是一个字符字面值。

5.关于转义
- \后3个八进制字符。
- \x后任意个十六进制字符。

6.初始化与赋值
- 初始化与赋值的区别 </br>
>初始化不是赋值，初始化的含义是创建变量时赋予其一个初始值，而赋值的含义是把对象的当前值擦除，而以一个新的值代替

一句话概括就是：初始化操作调用的类型的拷贝构造函数，而赋值则调用的是类型的赋值运算符=，[更多参考](http://www.cnblogs.com/codingthings/archive/2012/04/25/2470610.html)</br>
- 初始化的方式 </br>
>long double value = 3.1415926536; </br>
int a =  value;//可以，存在丢失精度问题 </br>
int b = {value},c{value};//不可以，编译器报丢失精度错误，转换不能完成 </br>
int c(value);//可以，同样存在都是精度问题 </br>

在MinGW上测试只会报出一个类型转化的警告[尴尬0.0]</br>

7.关于声明和定义
- extern关键字 </br>
声明！声明！声明！一个变量，而不是定义。任何包含显示初始化的声明将变成一个定义<br>
如：extern int i = 5;//这是个定义，且这条语句出现在函数体内将会出现错误。
- 应用::(作用域运算符)获取全局变量</br>
当全局变量与局部变量同名时，可以用::var\_name获取全局的var\_name变量。但这很无聊，尽量避免吧</br>

8.关于引用和指针
- 引用必须初始化
- 引用只能绑定在变量上
- 不能定义引用的指针
- 不能定义引用的引用</br>
注：在MinGW上编译通过了引用的引用，引用的指针[好尴尬]</br>
- 指针的初始化方式</br>
>int \*ptr = NULL;//需要导入stdlib.h </br>
int \*ptr = 0; </br>
int \*ptr = nullptr;//C++11 新加入。</br>
int a = 0;</br>
int \*ptr = a;//错误，不能将变量的值直接赋给指针变量，即使值为0也不行 </br>

- 指针的定义尽力推到它需要指向内容定义之后，指针初始化是一个好习惯。
- C++二逼笔试题爱考关于引用、指针声明的内容</br>
先说明一个概念：C++声明形式:数据类型符 声明符。这里的声明符包含了类型修饰符和变量名，这也是最爱考的地方。声明符中的变量名就不多说了，关于类型修饰符说一下。类型修饰符包括：*、&、[]等（还有其他吗？不知道，现在脑子就这三个）。一般考试会这样考：</br>
>int* a，b;//a、b分别是什么类型？（其他同理）</br>

分析：数据类型符 声明符 = int *a，b。所以a是指针变量，b是整型变量。
- 关于含有多个类型修饰符的声明符最后的方式是从右向左一次解读意义。</br>

9.关于const
- const默认是文件作用域，也就是说在离开了该文件，其他文件对该const不可见。</br>
原因是C++编译器可能会进行编译优化，将所有const替换为具体的值。
- const变量分享的方法是，不管声明还是定义都加上*extend*关键字。
- 允许为一个常量引用绑定非常量的对象、字面值、甚至一个表达式。</br>
一个字面值可以是一个常量，所以普通引用不能绑定上去。但常量应用可以绑定到常量或者变量上。
- 常量引用可以绑定任何兼容的类型上。</br>
>double pi = 3.14;</br>
int &i = pi //错误，普通引用必须和绑定的类型相同</br>
const int &i = pi; //正确，pi会先进行类型装换，i相当于绑定在常量3上<br>

- 常量的指针 与 指针常量</br>
>const int *p;//p是一个指向常量的指针，这里的指向常量只是说明不能通过指针去改变那个值。至于它是不是常量无所谓。</br>
int i = 1;</br>
int *const p = &i;//p是一个指向整型的指针常量，注意常量是修饰指针的，也就是指针本身是常量，而不是其指向的值。这等价于p始终是指向i的，不能修改p指向其他变量，但可以通过p去修改i。<br>
const int *const p = &i;//这个限制更加严格，不仅指针本身是个常量不能改变，而且其指向的值也是常量，也不能通过指针去改变值。

- int const 与 const int 是一个东西，至少MinGW认为他们是一样的，但个人觉得避免第一种写法。
- 从右向左确定指针、引用变量的类型在带const时特别有效。
- 复合类型中低层const、顶层const对赋值的影响</br>
顶层const表示任意的对象是常量，底层const表示指针指向一个常量。</br>
>int i = 0;<br>
const int &j = i;//左边的const为底层const，它代表着j引用的值是不可变的。j本身就不可变，所以引用不存在顶层const</br>
const int *const k = &i;//左边的const是底层const，它代表k指向的值不能改变，右边的const是顶层const，它代表k本身不能改变。</br>

现在要讨论的是什么时候对象间的赋值是允许的？首先顶层const对对象间的赋值没有影响，其次底层const必须兼容：赋值符=左边变量的底层const存在时，不管右边变量有无底层const赋值都是允许的。但如果左边对象没有底层const则右边必须也是没有底层const。</br>
- constexpr定义顶层const</br>
consteptr定义的变量必须有固定的地址。
- constexptr变量会让编译器主动去检查它是不是一个常量表达式。如果不是（编译期间不可以确定下来值），那么就会报错。
- 定义指针为constexptr时，需要注意这样的指针应该指向全局的变量，而不是某个函数里的。</br>
这是因为函数体内的变量地址不是固定不变的，不能再编译期间确定下来。而全局变量的地址是确定的。</br>

10.类型别名带来的易错理解
- typedef、using都可以用来为类型起别名。
- 易错理解：</br>
> typedef int *intptr;</br>
const intptr p = 0;</br>
const intptr *q;</br>

上面第二、三句是最容易理解错的。很自然的我们会把上面语句翻译成下面的形式：</br>
> const int *p=0;</br>
const int **q;</br>

这相当于进行了一下替换，但是这种替换是不对的。在const inptr p = 0中，在上面关于变量的声明中，说过声明的格式为：数据类型符 声明符，且从右往左看。p是声明符，const intptr是类型符，也就是说p的类型是intptr常量型，即整型指针常量。所以p的正确类型是一个指向int的常量指针，而不是转换形式中的指向整数常量的指针。同样q应该是指向一个整型的指针常量的指针。</br>

11.auto类型推导：
- auto声明的变量时让编译器根据初始值来推导变量的类型。也就是说变量必须进行初始化。
- 多个变量用auto声明在一条语句中时，必须保证各个变量的数据类型一致。
- auto会忽略掉顶层const而保留底层const

12.decltype类型推导：
- decltype(表达式)：这将产生一个类型，该类型就是表达式的类型。
- decltype保留顶层const和引用。
- 记住三种情况：
> int i = 0,*p=&i,&r=i;
decltype(r) = int&
decltype(*p) = int&
decltype(i) = int
decltype((i)) = int&,双层括号永远是引用。

### C++编译
预处理、编译单元编译、链接、汇编码、机器码：[编译详解](http://wiki.ubuntu.org.cn/Compiling_Cpp)


## 第三章：字串串、向量、和数组
1.关于using解命名空间
- 不要在头文件中用using引入某个名字空间的变量。

2.关于string
- string的size()返回的是所占的空间数。中文不是字符数。
- 不用讲size()返回的值与整数进行运算，应为他是个unsigned类型。
- 字符串字面值不是string,因为C++要兼容C，所以字符串字面值是char*  
- 不能把字面值相加，如下语句是错误,但java中时合法的</br>
>string s = "fall" + "blank";

3.关于vector
- vector里放的真是对象，这点和java不同
- vector使用策略：先建立空vector对象，然后push_back()往里面添加元素。
- vector不是一个类型，它是一个模板类。

4.关于数组
- 不能把数组拷贝给其他数组作为初始值、或者直接赋值。
- 和Java不同，C++数组的长度是在编译期间决定的。这以为着不能使用变量作为数组长度。
- iterator头文件中定义的begin、end函数可以是类似迭代器类似的功能。

## 第六章：函数
1.关于传参
- 形参会被忽略掉顶层const<br>
> void func(const int i)<br>
> void func(int i)<br>

这是不算是重载，因为形参的顶层const被忽略。ps：被忽略并不是没有用
- 尽量选用常量引用，除非你的目的是在函数体中改变它，否则选用常量引用。<br>
非常量引用带来的问题：1.意外的修改了参数。2.不能作用于常量参数的调用。3.不能作用于字面值的调用。
> void func(string &s)<br>
> void func(const string &s)<br>

上述两个函数，第一个不能作用于func("song").

## 第七章：C++类
1. 常量函数
2. 作用域寻找
3. 类内型声明
4. 友元声明

## 第八章：IO
1.流状态：<br>
- iostate:流状态
- badbit：流崩溃
- failbit：流操作失败
- eofbit：流到文件结束
- goodbit：流正常状态
